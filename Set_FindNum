string secondOrder(std::vector<int> arr) //vector{3,3,1,2,2}
{
    set<int> s(arr.begin(), arr.end()); //sao chép vector sang set và dã đc set lọc lại và sắp xếp tăng dần
    if(s.size() == 1) return "NO";
    else
    {
        set<int>:: iterator it = ++s.begin(); //nếu set nhiều hơn 1 phần tử thì mình tạo ra 1 con trỏ chỉ vào ô đầu tiên rồi + nó lên để nó sang ô thứ 2(ô cần lấy giá trị), lưu ý là ++s là cộng s trc rồi mới gán vào con trỏ it còn nếu ghi s++ thì gán it cho ô 1 trc rồi mới + sau thì sẽ sai
        //hoặc set<int>:: iterator it = s.begin();
        //s.advance(it, 1);
        return to_string(*it); //xuất giá trị ô 2, do giá trị vector đang giữ là kiểu int nên phải dùng to_string  chuyển về string
    }
}
-------------------------------------------------
Để kiểm tra một giá trị có tồn tại trong một set hay không, ta sẽ dùng hàm find() (Độ phức tạp O(logN)).

Hàm s.find(x) sẽ trả về iterator trỏ đến phần tử mang giá trị x trong set s, nếu không tồn tại giá trị x trong s thì hàm sẽ trả về s.end().

Ví dụ:

	set <int>:: iterator it = s.find(x); // lấy con trỏ đang trỏ đến số có giá rị x
	if (it == s.end()){ // nếu không tồn tại giá trị x trong set s
		...
	}else{ // có tồn tại giá trị x trong set s
		...
	}

-----------------------------------
//hàm tìm k 
bool setFind(std::vector<int> arr, int k)
{
    std::set<int> s(arr.begin(), arr.end());
    set<int>:: iterator it = s.find(k);
    if(it == s.end()) return false;
    else return true;
    //return it != s.end;
    //return (s.find(k) != end()) ?true : false;
}
------------------------------------------------------------------------
Trong bài này chúng ta sẽ tìm hiểu về hai hàm:

upper_bound() :  Trả về iterator đến vị trí phần tử nhỏ nhất mà lớn hơn khóa, nếu không tìm thấy trả về vị trí “end” của set.. ĐPT O(logN). 
lower_bound() : Trả về iterator đến vị trí phần tử nhỏ nhất mà không nhỏ hơn (lớn hơn hoặc bằng) khóa (dĩ nhiên là theo phép so sánh), nếu không tìm thấy trả về vị trí “end” của set. ĐPT O(logN).
Ví dụ:

	// s = {1,2,3,4,5}
	set <int>:: iterator it = s.lower_bound(4);
	if (it == s.end()){
		cout << -1;
	}else{
		cout << *it;
	}
	//Kết quả sẽ là 4

	it = s.upper_bound(4);
	if (it == s.end()){
		cout << -1;
	}else{
		cout << *it;
	}
	//Kết quả sẽ là 5

---------
//Hàm 
std::vector<int> setFunction(std::vector<int> arr, int k)
{
    int m,n;
    std::set<int> s(arr.begin(), arr.end());
    set <int>:: iterator it;
    it = s.lower_bound(k);
    if(it == s.end())
    {
        n = -1;
        cout << n;
    }
    else
    {
        n = *it;
        cout << n;
    }
        
    it = s.upper_bound(k);
    if(it == s.end())
    {
        m = -1;
        cout << m;
    }
    else
    {
        m = *it;
        cout << m;
    }

    return {m,n};
}
